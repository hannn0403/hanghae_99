## 제목: 99클럽 코테 스터디 6일차 TIL + 오늘의 학습 키워드

- **오늘의 학습 키워드:** BFS (Flood Fill) 
- **공부한 내용 본인의 언어로 정리하기:** Flood Fill을 통해서 섬의 갯수를 결정할 수 있다.  
- **오늘의 회고**
  - **어떤 문제가 있었고, 나는 어떤 시도를 했는지:** BFS에서 알고 있는 Flood Fill 알고리즘을 활용해서 해당 array에서 몇개의 섬이 존재하고 있는 지 알 수 있다.  
  - **어떻게 해결했는지:** BFS를 통해서 방문하지 않은 점을 돌아가면서 8가지 방향으로 Queue를 써가면서 Flood Fill을 구현할 수 있다. 
  - **무엇을 새롭게 알았는지:**  
  - **내일 학습할 것은 무엇인지**
 
  
필수 해시태그: #99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL

---
## 코드
```from collections import deque


def print_arr(arr):
    n, m = len(arr), len(arr[0])
    for i in range(n):
        for j in range(m):
            print(f"{arr[i][j]:<3}", end=" ")
        print()
    print()


def flood_fill(start_y, start_x, graph, visited, new_color):
    n, m = len(graph), len(graph[0])
    dy = [-1, 1, 0, 0, -1, -1, 1, 1]
    dx = [0, 0, -1, 1, -1, 1, -1, 1]

    visited[start_y][start_x] = True
    queue = deque([(start_y, start_x)])

    while queue:
        y, x = queue.popleft()
        graph[y][x] = new_color

        for i in range(8):
            ny, nx = y + dy[i], x + dx[i]
            if 0 <= ny < n and 0 <= nx < m:
                if graph[ny][nx] and not visited[ny][nx]:
                    queue.append((ny, nx))
                    visited[ny][nx] = True


def flood_fill_solution(graph):
    n, m = len(graph), len(graph[0])
    visited = [[False] * m for _ in range(n)]
    new_color = -1

    for y in range(n):
        for x in range(m):
            if graph[y][x] == 1 and not visited[y][x]:
                flood_fill(y, x, graph, visited, new_color)
                new_color -= 1

    return -1 * (new_color + 1)


while True:
    w, h = map(int, input().split())
    # 입력의 마지막 줄인 경우 while문을 빠져 나온다.
    if w == 0 and h == 0:
        break

    arr = []
    for i in range(h):
        row = list(map(int, input().split()))
        arr.append(row)

    # print_arr(arr)

    island_num = flood_fill_solution(arr)
    # print(f"island_num : {island_num}")
    print(island_num)

